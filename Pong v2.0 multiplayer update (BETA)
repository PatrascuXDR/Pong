// ===================== ORIGINAL INCLUDES =====================
#include <fstream>
#include <iostream>
#include <string>
#include <time.h>
#include <chrono>
#include <thread>
#include <cstdlib>
#include <conio.h>
#include <stdlib.h>
#include <random>

// ===================== NETWORK INCLUDES (NEW) =====================
#include <winsock2.h>
#include <windows.h>
#include <ws2tcpip.h>

using namespace std;

// ===================== ORIGINAL GLOBALS =====================
char a[21][36], x;
int i, j, p = -1, r = -1, scor[2], ps[3] = {0, 8, 12}, pd[3] = {0, 8, 12}, dificultate, scor_sp, highScore, random;
const int n = 35, m = 20;
bool atins, mod, skip, pause;

// ===================== NETWORK GLOBALS (NEW) =====================
SOCKET gSock = INVALID_SOCKET;
sockaddr_in gPeerAddr{};
int gPeerAddrLen = sizeof(gPeerAddr);
bool gIsHost = false;

// ===================== NETWORK PACKETS (NEW) =====================
#pragma pack(push, 1)
struct JoinPacket {
    int magic;       // 'PONG' magic
    int version;     // 1
};
struct ConfigPacket {
    int dificultate; // host-selected difficulty
};
struct InputPacket {
    int move;        // -1 up, 0 none, 1 down
};
struct StatePacket {
    int i, j, p, r;
    int ps1, ps2;
    int pd1, pd2;
    int scor0, scor1;
};
#pragma pack(pop)

// ===================== ORIGINAL FUNCTIONS =====================
void ShowConsoleCursor(bool showFlag)
{
    HANDLE out = GetStdHandle(STD_OUTPUT_HANDLE);
    CONSOLE_CURSOR_INFO cursorInfo;
    GetConsoleCursorInfo(out, &cursorInfo);
    cursorInfo.bVisible = showFlag;
    SetConsoleCursorInfo(out, &cursorInfo);
}
void load()
{
    ifstream f("save.txt");
    f >> highScore;
    f.close();
}
bool select_diff(){
    if (GetAsyncKeyState(0x31) & 0x0001) { dificultate = 200; return 1; }
    if (GetAsyncKeyState(0x32) & 0x0001) { dificultate = 150; return 1; }
    if (GetAsyncKeyState(0x33) & 0x0001) { dificultate = 100; return 1; }
    if (GetAsyncKeyState(0x34) & 0x0001) { dificultate = 50; return 1; }
    if (GetAsyncKeyState(0x35) & 0x0001) { dificultate = 1; return 1; }
    return 0;
}
void help_menu(){
    cout << "W S controleaza peretele din stanga, iar sageata sus si jos cel din dreapta.\nPentru singleplayer se joaca doar cu W S,\n";
    cout << "iar dificultatea modifica viteza mingii si sansa ca bot-ul sa miste peretele sau astfel:\n";
    cout << "Incepator: O miscare a mingii la fiecare 200ms + sansa de 20% ca miscarea bot-ului sa dea fail;\n";
    cout << "Usor: O miscare a mingii la fiecare 150ms + sansa de 15% ca miscarea bot-ului sa dea fail;\n";
    cout << "Mediu: O miscare a mingii la fiecare 100ms + sansa de 10% ca miscarea bot-ului sa dea fail;\n";
    cout << "Greu: O miscare a mingii la fiecare 50ms + sansa de 5% ca miscarea bot-ului sa dea fail;\n";
    cout << "Inuman: O miscare a mingii la fiecare 1ms + bot-ul se va misca garantat.\n";
    cout << "Pentru multiplayer dificultatea schimba doar viteza jocului la valorite antementionate.";
    cout << "Apasa SPACE pentru a te intoarce la meniul principal.";
}
void MainMenu()
{
    system("cls");
    while(1){
        cout << "   P I N G  P O N G\n";
        cout << "|     |\n";
        cout << "|O    |\n";
        cout << "|     |\n";
        cout << "Selecteaza dificultatea: (dificultatea este doar un modificator de viteza)\n1.Incepator\n2.Usor\n3.Mediu\n4.Greu\n5.Inuman\nApasa h pentru help menu";
        if (GetAsyncKeyState(VK_ESCAPE) & 0x0001) exit(0);
        else if (GetAsyncKeyState('H') & 0x0001){
            Sleep(1000);
            system("cls");
            help_menu();
            while(1) if (GetAsyncKeyState(VK_SPACE)) break;
        }
        if (select_diff()) break;
        Sleep(400);
        system("cls");
        cout << "   P I N G  P O N G\n";
        cout << "|     |\n";
        cout << "|  O  |\n";
        cout << "|     |\n";
        cout << "Selecteaza dificultatea: (dificultatea este doar un modificator de viteza)\n1.Incepator\n2.Usor\n3.Mediu\n4.Greu\n5.Inuman\nApasa h pentru help menu";
        if (GetAsyncKeyState(VK_ESCAPE) & 0x0001) exit(0);
        else if (GetAsyncKeyState('H') & 0x0001){
            Sleep(1000);
            system("cls");
            help_menu();
            while(1) if (GetAsyncKeyState(VK_SPACE)) break;
        }
        if (select_diff()) break;
        Sleep(400);
        system("cls");
        cout << "   P I N G  P O N G\n";
        cout << "|     |\n";
        cout << "|    O|\n";
        cout << "|     |\n";
        cout << "Selecteaza dificultatea: (dificultatea este doar un modificator de viteza)\n1.Incepator\n2.Usor\n3.Mediu\n4.Greu\n5.Inuman\nApasa h pentru help menu";
        if (GetAsyncKeyState(VK_ESCAPE) & 0x0001) exit(0);
        else if (GetAsyncKeyState('H') & 0x0001){
            Sleep(1000);
            system("cls");
            help_menu();
            while(1) if (GetAsyncKeyState(VK_SPACE)) break;
        }
        if (select_diff()) break;
        Sleep(400);
        system("cls");
        cout << "   P I N G  P O N G\n";
        cout << "|     |\n";
        cout << "|  O  |\n";
        cout << "|     |\n";
        cout << "Selecteaza dificultatea: (dificultatea este doar un modificator de viteza)\n1.Incepator\n2.Usor\n3.Mediu\n4.Greu\n5.Inuman\nApasa h pentru help menu";
        if (GetAsyncKeyState(VK_ESCAPE) & 0x0001) exit(0);
        else if (GetAsyncKeyState('H') & 0x0001){
            Sleep(1000);
            system("cls");
            help_menu();
            while(1) if (GetAsyncKeyState(VK_SPACE)) break;
        }
        if (select_diff()) break;
        Sleep(400);
        system("cls");
    }
    system("cls");
}
void setup()
{
    load();
    atins = 0; x = ' ';
    i = 10; j = 20;
    ps[1] = 8; ps[2] = 12;
    pd[1] = 8; pd[2] = 12;
    p = -1; r = 0;
    scor_sp = 0;
    skip = 0;
    int ii, jj;
    for (ii = 1; ii < 8; ii ++) a[ii][1] = a[ii][n] = ' ';
    for (ii = 13; ii < m; ii ++) a[ii][1] = a[ii][n] = ' ';
    for (ii = 1; ii <= n; ii ++) a[0][ii] = '_', a[m][ii] = '_';
    for (ii = 8; ii <= 12; ii ++) a[ii][1] = a[ii][n] = '|';
    for (ii = 1; ii < m; ii ++)
        for (jj = 2; jj < n; jj ++)
            a[ii][jj] = ' ';
    a[10][20] = 'O';
}
void afisare()
{
    system("cls");
    int ii, jj;
    for (ii = 0; ii <= 20; ii ++){
        for (jj = 1; jj <= n; jj ++)
            cout << a[ii][jj];
        cout << "\n";
    }
    if (mod) cout << "Jucator1  " << scor[0] << "             Jucator2  " << scor[1];
    else cout << "Scor: " << scor_sp << "             HighScore:  " << highScore;
}
void save()
{
    fstream f("save.txt", ios::in | ios::out | ios::trunc);
    f << highScore;
    f.close();
}
void mode_select(){
    system("cls");
    cout << "Selecteaza modul(1/2):\n1 - singleplayer\n2 - multiplayer\n";
    cout << "Modul singleplayer a fost facut teoretic imposibil de batut, \nasa ca scorul creste de fiecare daca cand lovesti mingea.";
    cout << "\n\nApasa butonul '-' pentru a sterge highScore-ul (singleplayer)";
    cout << "\nHighScore curent: " << highScore;
    cout << "\n\nTip: Poti apasa ESCAPE oricand pentru a te intoarce la meniul principal/inchide jocul";
}

// ===================== NEW: helper to draw paddles+ball into a[][] =====================
void rebuild_board_from_state() {
    // clear inner area
    for (int ii = 1; ii < m; ii++)
        for (int jj = 2; jj < n; jj++)
            a[ii][jj] = ' ';

    // clear paddle columns
    for (int ii = 1; ii < m; ii++) {
        a[ii][1] = ' ';
        a[ii][n] = ' ';
    }

    // draw paddles
    for (int ii = ps[1]; ii <= ps[2]; ii++) a[ii][1] = '|';
    for (int ii = pd[1]; ii <= pd[2]; ii++) a[ii][n] = '|';

    // draw ball
    if (i >= 1 && i <= m-1 && j >= 2 && j <= n-1)
        a[i][j] = 'O';
}

// ===================== NEW: network init/teardown =====================
bool net_init_common() {
    WSADATA wsa{};
    if (WSAStartup(MAKEWORD(2,2), &wsa) != 0) return false;

    gSock = socket(AF_INET, SOCK_DGRAM, 0);
    if (gSock == INVALID_SOCKET) return false;

    // non-blocking
    u_long nb = 1;
    ioctlsocket(gSock, FIONBIO, &nb);
    return true;
}
void net_close() {
    if (gSock != INVALID_SOCKET) {
        closesocket(gSock);
        gSock = INVALID_SOCKET;
    }
    WSACleanup();
}

// ===================== NEW: online setup (host/client) =====================
bool online_setup_host() {
    if (!net_init_common()) return false;
    gIsHost = true;

    sockaddr_in bindAddr{};
    bindAddr.sin_family = AF_INET;
    bindAddr.sin_port = htons(7777);
    bindAddr.sin_addr.s_addr = INADDR_ANY;

    if (bind(gSock, (sockaddr*)&bindAddr, sizeof(bindAddr)) != 0) return false;

    system("cls");
    cout << "ONLINE HOST\n";
    cout << "Waiting for client... (client must send join)\n";

    // wait for join packet (blocking-ish loop, but without freezing gameplay)
    JoinPacket jp{};
    while (true) {
        int ret = recvfrom(gSock, (char*)&jp, sizeof(jp), 0, (sockaddr*)&gPeerAddr, &gPeerAddrLen);
        if (ret == sizeof(jp) && jp.magic == 0x474E4F50 /*'PONG'*/ && jp.version == 1) break;
        if (GetAsyncKeyState(VK_ESCAPE) & 0x0001) return false;
        Sleep(10);
    }

    // send difficulty config to client (host chosen)
    ConfigPacket cfg{ dificultate };
    sendto(gSock, (char*)&cfg, sizeof(cfg), 0, (sockaddr*)&gPeerAddr, gPeerAddrLen);

    return true;
}

bool online_setup_client() {
    if (!net_init_common()) return false;
    gIsHost = false;

    system("cls");
    cout << "ONLINE CLIENT\n";
    cout << "Enter host IP (LAN): ";

    string ip;
    cin.clear();
    cin.ignore(10000, '\n');
    getline(cin, ip);         // waits here, no refresh happening

    gPeerAddr = {};
    gPeerAddr.sin_family = AF_INET;
    gPeerAddr.sin_port = htons(7777);
    gPeerAddr.sin_addr.s_addr = inet_addr(ip.c_str());

    // send join
    JoinPacket jp{ 0x474E4F50 /*'PONG'*/, 1 };
    sendto(gSock, (char*)&jp, sizeof(jp), 0, (sockaddr*)&gPeerAddr, gPeerAddrLen);

    // wait for difficulty config
    ConfigPacket cfg{};
    while (true) {
        int ret = recvfrom(gSock, (char*)&cfg, sizeof(cfg), 0, nullptr, nullptr);
        if (ret == sizeof(cfg)) break;
        if (GetAsyncKeyState(VK_ESCAPE) & 0x0001) return false;
        Sleep(10);
    }
    dificultate = cfg.dificultate; // host controls difficulty (your requirement)
    return true;
}

// ===================== NEW: online multiplayer loop =====================
// IMPORTANT: host runs YOUR original physics/scoring, client only renders state from host.
void online_multiplayer_loop() {
    mod = 1;
    setup(); // host and client start from clean state

    while (1) {
        // Escape to exit online match
        if (GetAsyncKeyState(VK_ESCAPE) & 0x8000) {
            scor[0] = scor[1] = 0;
            system("cls");
            break;
        }

        if (gIsHost) {
            // ================= HOST: left paddle local input =================
            if (GetAsyncKeyState('W') & 0x8000 && ps[1] > 1)
                ps[1]--, ps[2]--;
            else if (GetAsyncKeyState('S') & 0x8000 && ps[2] < m - 1)
                ps[1]++, ps[2]++;

            // ================= HOST: receive client input for right paddle =================
            InputPacket ip{};
            int ret = recvfrom(gSock, (char*)&ip, sizeof(ip), 0, nullptr, nullptr);
            if (ret == sizeof(ip)) {
                if (ip.move == -1 && pd[1] > 1) pd[1]--, pd[2]--;
                else if (ip.move == 1 && pd[2] < m - 1) pd[1]++, pd[2]++;
            }

            // ================= HOST: YOUR ORIGINAL BALL + SCORE LOGIC (same math) =================
            if ((j == 2 || j == n - 1) && !atins) r = -1, atins = 1;

            // move ball on board representation
            rebuild_board_from_state();
            // ball 'O' currently at a[i][j]
            // emulate your swap logic but without relying on old 'a' contents
            // IMPORTANT CHANGE: we update (i,j) first and then rebuild board.
            // This keeps the same movement math: i+=r, j+=p.
            i += r; j += p;

            if (r == 1 && i + r >= m) r = -r;
            else if (r == -1 && i + r < 1) r = -r;

            // paddle collision
            if ((j == 2 && i >= ps[1] && i <= ps[2]) ||
                (j == n - 1 && i >= pd[1] && i <= pd[2])) {
                p = -p;
            }

            // scoring when ball passes edges (same as your code intent)
            if (j <= 1){
                cout << "\n\nJucator2 a primit un punct";
                scor[1] ++;
                this_thread::sleep_for(chrono::seconds(1));
                x = getch();
                setup();
                x = ' ';
            }
            else if (j >= n){
                cout << "\n\nJucator1 a primit un punct";
                scor[0] ++;
                this_thread::sleep_for(chrono::seconds(1));
                x = getch();
                setup();
                x = ' ';
            }

            // rebuild board after sim update
            rebuild_board_from_state();

            // send state to client
            StatePacket st{ i, j, p, r, ps[1], ps[2], pd[1], pd[2], scor[0], scor[1] };
            sendto(gSock, (char*)&st, sizeof(st), 0, (sockaddr*)&gPeerAddr, gPeerAddrLen);

            afisare();
        } else {
            // ================= CLIENT: send input only =================
            InputPacket ip{};
            ip.move = 0;
            if (GetAsyncKeyState(VK_UP) & 0x8000) ip.move = -1;
            else if (GetAsyncKeyState(VK_DOWN) & 0x8000) ip.move = 1;
            sendto(gSock, (char*)&ip, sizeof(ip), 0, (sockaddr*)&gPeerAddr, gPeerAddrLen);

            // receive state from host
            StatePacket st{};
            int ret = recvfrom(gSock, (char*)&st, sizeof(st), 0, nullptr, nullptr);
            if (ret == sizeof(st)) {
                i = st.i; j = st.j; p = st.p; r = st.r;
                ps[1] = st.ps1; ps[2] = st.ps2;
                pd[1] = st.pd1; pd[2] = st.pd2;
                scor[0] = st.scor0; scor[1] = st.scor1;

                rebuild_board_from_state();
            }

            afisare();
        }

        this_thread::sleep_for(chrono::milliseconds(dificultate));
    }
}

// ===================== NEW: multiplayer submenu =====================
char multiplayer_submenu() {
    system("cls");
    cout << "Multiplayer:\n1 - Local (same PC)\n2 - Online (P2P LAN)\nESC - back\n";
    while (true) {
        if (GetAsyncKeyState(0x31) & 0x0001) return '1';
        if (GetAsyncKeyState(0x32) & 0x0001) return '2';
        if (GetAsyncKeyState(VK_ESCAPE) & 0x0001) return 0;
        Sleep(50);
    }
}

int main()
{
    mt19937 rng(random_device{}());
    uniform_int_distribution<int> dist(1, 100);
    ShowConsoleCursor(false);

    while (1){
        setup();
        MainMenu();
        system("cls"); x = 0;
        Sleep(1000);
        mode_select();

        while(x != '1' && x != '2'){
            if (GetAsyncKeyState(0x31) & 0x0001) x = '1';
            if (GetAsyncKeyState(0x32) & 0x0001) x = '2';
            if (GetAsyncKeyState(VK_ESCAPE) & 0x0001) {skip = 1; break;}
            else if(GetAsyncKeyState(0xBD) & 0x0001){ // pentru sters scor
                Sleep(500);
                cout << "\nEsti sigur? Apasa '-' din nou pentru a confirma sau apasa SPACE buton pentru a reveni.";
                while(1){
                    if(GetAsyncKeyState(0xBD) & 0x0001){
                        highScore = 0;
                        save();
                        mode_select();
                        Sleep(1000);
                        break;
                    }
                    else if (GetAsyncKeyState(VK_SPACE) & 0x0001){
                        mode_select();
                        break;
                    }
                }
            }
        }

        if (x == '1' && !skip){
            // ===================== ORIGINAL SINGLEPLAYER (UNCHANGED) =====================
            while(1){
                afisare();
                if (GetAsyncKeyState(VK_ESCAPE) && 0x0001){
                    scor[0] = scor[1] = 0;
                    system("cls");
                    break;
                }
                if (GetAsyncKeyState('W') && 0x8000 && ps[1] > 1) a[ps[1] - 1][1] = '|', a[ps[2]][1] = ' ', ps[1] --, ps[2] --, Sleep(10);
                else if (GetAsyncKeyState('S') && 0x8000 && ps[2] < m - 1) a[ps[1]][1] = ' ', ps[1] ++, a[ps[2] + 1][1] = '|', ps[2] ++, Sleep(10);
                // auto
                random = dist(rng);
                if (random > dificultate / 10){
                    if (dificultate != 1 || scor_sp < 100){
                        if (i < pd[1] + 2 && pd[1] > 1) a[pd[1] - 1][n] = '|', a[pd[2]][n] = ' ', pd[1] --, pd[2] --;
                        else if (i > pd[2] - 2 && pd[2] < m - 1) a[pd[1]][n] = ' ', pd[1] ++, a[pd[2] + 1][n] = '|', pd[2] ++;
                    }
                }
                // final auto
                if ((j == 2 || j == n - 1) && !atins) r = -1, atins = 1;
                swap(a[i][j], a[i + r][j + p]);
                i += r; j += p;
                if (r == 1 && i + r >= m) r = -r;
                else if (r == -1 && i + r < 1) r = -r;
                if (j == 2 && a[i][j + p] == '|'){
                    p = -p;
                    scor_sp ++;
                    if (scor_sp > highScore) highScore = scor_sp;
                    save();
                }
                if (j == n - 1 && a[i][j + p] == '|') p = -p;
                if (j == 1){
                    cout << "\n\nCalculatorul a primit un punct";
                    scor_sp = 0;
                    this_thread::sleep_for(chrono::seconds(1));
                    x = getch();
                    setup();
                    x = ' ';
                }
                else if (j == n){
                    cout << "\n\nBravo baiete!!";
                    this_thread::sleep_for(chrono::seconds(1));
                    x = getch();
                    setup();
                    x = ' ';
                }
                this_thread::sleep_for(chrono::milliseconds(dificultate));
            }
        }
        else if (x == '2' && !skip){
            // ===================== MULTIPLAYER CHOICE (NEW) =====================
            char mp = multiplayer_submenu();
            if (!mp) continue;

            if (mp == '1') {
                // ===================== ORIGINAL LOCAL MULTIPLAYER (UNCHANGED) =====================
                mod = 1;
                while(1){
                    afisare();
                    if (GetAsyncKeyState(VK_ESCAPE) && 0x8000){
                        scor[0] = scor[1] = 0;
                        system("cls");
                        break;
                    }
                    if (GetAsyncKeyState('W') && 0x8000 && ps[1] > 1) a[ps[1] - 1][1] = '|', a[ps[2]][1] = ' ', ps[1] --, ps[2] --;
                    else if (GetAsyncKeyState('S') && 0x8000 && ps[2] < m - 1) a[ps[1]][1] = ' ', ps[1] ++, a[ps[2] + 1][1] = '|', ps[2] ++;
                    if (GetAsyncKeyState(VK_UP) && 0x8000 && pd[1] > 1) a[pd[1] - 1][n] = '|', a[pd[2]][n] = ' ', pd[1] --, pd[2] --;
                    else if (GetAsyncKeyState(VK_DOWN) && 0x8000 && pd[2] < m - 1) a[pd[1]][n] = ' ', pd[1] ++, a[pd[2] + 1][n] = '|', pd[2] ++;
                    if ((j == 2 || j == n - 1) && !atins) r = -1, atins = 1;
                    swap(a[i][j], a[i + r][j + p]);
                    i += r; j += p;
                    if (r == 1 && i + r >= m) r = -r;
                    else if (r == -1 && i + r < 1) r = -r;
                    if ((j == 2 && a[i][j + p] == '|') || (j == n - 1 && a[i][j + p] == '|')) p = -p;
                    if (j == 1){
                        cout << "\n\nJucator2 a primit un punct";
                        scor[1] ++;
                        this_thread::sleep_for(chrono::seconds(1));
                        x = getch();
                        setup();
                        x = ' ';
                    }
                    else if (j == n){
                        cout << "\n\nJucator1 a primit un punct";
                        scor[0] ++;
                        this_thread::sleep_for(chrono::seconds(1));
                        x = getch();
                        setup();
                        x = ' ';
                    }
                    this_thread::sleep_for(chrono::milliseconds(dificultate));
                }
            } else if (mp == '2') {
                // ===================== ONLINE MULTIPLAYER (NEW) =====================
                system("cls");
                cout << "Online P2P:\n1 - Host\n2 - Client\nESC - back\n";
                char role = 0;
                while (role != '1' && role != '2') {
                    if (GetAsyncKeyState(0x31) & 0x0001) role = '1';
                    if (GetAsyncKeyState(0x32) & 0x0001) role = '2';
                    if (GetAsyncKeyState(VK_ESCAPE) & 0x0001) { role = 0; break; }
                    Sleep(50);
                }
                if (!role) continue;

                bool ok = false;
                if (role == '1') ok = online_setup_host();
                else ok = online_setup_client();

                if (!ok) {
                    net_close();
                    continue;
                }

                online_multiplayer_loop();
                net_close();
            }
        }
        save();
    }
    return 0;
}


